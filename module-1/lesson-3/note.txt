Basic Error Handling

Error handling in JavaScript (and Node.js) is crucial for building robust applications that can gracefully handle unexpected situations. Below, I’ll explain the basics of error handling in JavaScript/Node.js, covering key concepts, techniques, and examples. I'll keep it concise yet comprehensive, focusing on practical approaches.

### 1. **Understanding Errors in JavaScript**
Errors are objects in JavaScript that represent runtime issues. They can be:
- **Built-in Errors**: Like `Error`, `TypeError`, `ReferenceError`, `SyntaxError`, etc.
- **Custom Errors**: User-defined errors for specific cases.
- **Thrown Errors**: Explicitly triggered using the `throw` keyword.

Example of a built-in error:
```javascript
const err = new Error("Something went wrong!");
console.log(err.message); // Output: Something went wrong!
```

### 2. **Basic Error Handling with `try...catch`**
The `try...catch` block is the primary way to handle synchronous errors in JavaScript.

**Syntax**:
```javascript
try {
  // Code that might throw an error
} catch (error) {
  // Handle the error
} finally {
  // Optional: Code that runs regardless of error
}
```

**Example**:
```javascript
try {
  const data = JSON.parse("invalid json"); // This will throw a SyntaxError
} catch (error) {
  console.error("Error occurred:", error.message); // Output: Error occurred: Unexpected token i in JSON at position 0
} finally {
  console.log("Parsing attempt finished.");
}
```

- **Use Case**: Use `try...catch` for operations like JSON parsing, accessing undefined variables, or calling functions that might fail.
- **Note**: `try...catch` only works for **synchronous** code.

### 3. **Handling Asynchronous Errors**
Asynchronous code (e.g., `setTimeout`, Promises, or `async/await`) requires different approaches.

#### a) **Promises and `.catch()`**
Promises handle errors using the `.catch()` method.

**Example**:
```javascript
const fetchData = () => {
  return new Promise((resolve, reject) => {
    reject(new Error("Failed to fetch data"));
  });
};

fetchData()
  .then(data => console.log(data))
  .catch(error => console.error("Error:", error.message)); // Output: Error: Failed to fetch data
```

#### b) **Async/Await with `try...catch`**
For `async/await`, wrap the code in a `try...catch` block to handle rejected Promises.

**Example**:
```javascript
async function getData() {
  try {
    const response = await fetch("https://invalid-url");
    const data = await response.json();
    console.log(data);
  } catch (error) {
    console.error("Fetch error:", error.message); // Output: Fetch error: Failed to fetch
  }
}

getData();
```

### 4. **Error Handling in Node.js**
Node.js often uses callbacks or event emitters, which require specific error-handling patterns.

#### a) **Callback-Based Error Handling**
Node.js callbacks typically follow the "error-first" pattern, where the first argument is an error (if any).

**Example**:
```javascript
const fs = require("fs");

fs.readFile("nonexistent.txt", (err, data) => {
  if (err) {
    console.error("Error reading file:", err.message); // Output: Error reading file: ENOENT: no such file or directory...
    return;
  }
  console.log(data);
});
```

#### b) **Event Emitters**
Node.js event emitters (like streams) emit an `"error"` event when something goes wrong.

**Example**:
```javascript
const EventEmitter = require("events");
const emitter = new EventEmitter();

emitter.on("error", (err) => {
  console.error("Emitter error:", err.message);
});

emitter.emit("error", new Error("Something broke!")); // Output: Emitter error: Something broke!
```

### 5. **Creating Custom Errors**
You can extend the `Error` class to create custom error types for specific scenarios.

**Example**:
```javascript
class ValidationError extends Error {
  constructor(message) {
    super(message);
    this.name = "ValidationError";
  }
}

function validateUser(user) {
  if (!user.name) {
    throw new ValidationError("User name is required");
  }
}

try {
  validateUser({});
} catch (error) {
  console.error(`${error.name}: ${error.message}`); // Output: ValidationError: User name is required
}
```

### 6. **Global Error Handling**
To prevent crashes from unhandled errors, use global handlers.

#### a) **Unhandled Promise Rejections**
Handle uncaught Promise rejections to avoid Node.js process termination.

**Example**:
```javascript
process.on("unhandledRejection", (reason, promise) => {
  console.error("Unhandled Rejection:", reason.message);
});

Promise.reject(new Error("Async error")); // Output: Unhandled Rejection: Async error
```

#### b) **Uncaught Exceptions**
Catch unhandled synchronous errors (use sparingly, as this is a last resort).

**Example**:
```javascript
process.on("uncaughtException", (error) => {
  console.error("Uncaught Exception:", error.message);
  process.exit(1); // Exit to avoid undefined state
});

throw new Error("Critical error"); // Output: Uncaught Exception: Critical error
```

### 7. **Best Practices**
- **Be Specific**: Catch specific errors when possible (e.g., check `error.code` in Node.js).
- **Log Errors**: Use logging libraries (e.g., `winston` or `pino`) for production.
- **Graceful Degradation**: Provide fallback behavior when errors occur.
- **Avoid Silent Failures**: Always handle errors explicitly to avoid debugging headaches.
- **Clean Up Resources**: Use `finally` or cleanup functions to close files, connections, etc.
- **Validate Inputs**: Prevent errors by validating data early.

### 8. **Common Node.js Error Codes**
Node.js errors often include a `code` property. Examples:
- `ENOENT`: File/directory not found.
- `EACCESS`: Permission denied.
- `ECONNREFUSED`: Connection refused.

**Example**:
```javascript
const fs = require("fs");

fs.readFile("nonexistent.txt", (err) => {
  if (err && err.code === "ENOENT") {
    console.error("File not found!");
  }
});
```

### 9. **Example: Putting It Together**
Here’s a practical example combining synchronous and asynchronous error handling in Node.js:

```javascript
const fs = require("fs").promises;

async function readAndParseFile(filePath) {
  try {
    const data = await fs.readFile(filePath, "utf8");
    const parsed = JSON.parse(data);
    return parsed;
  } catch (error) {
    if (error.code === "ENOENT") {
      throw new Error(`File not found: ${filePath}`);
    } else if (error instanceof SyntaxError) {
      throw new Error("Invalid JSON format");
    } else {
      throw error;
    }
  }
}

async function main() {
  try {
    const result = await readAndParseFile("config.json");
    console.log("Parsed data:", result);
  } catch (error) {
    console.error("Error:", error.message);
  }
}

main();
```

### 10. **Resources for Further Learning**
- **MDN Web Docs**: Detailed JavaScript error reference (https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error).
- **Node.js Docs**: Error handling in Node.js (https://nodejs.org/api/errors.html).
- **xAI API**: If you’re building with APIs, check xAI’s API for advanced integrations (https://x.ai/api).

If you have specific scenarios or want deeper examples (e.g., Express.js error handling), let me know!