The `fs` (File System) module in Node.js provides an API for interacting with the file system in a synchronous or asynchronous manner. Since you specified avoiding the promise-based approach, I'll focus on the **callback-based** and **synchronous** methods of the `fs` module. Below, I'll explain the key concepts, methods, and provide examples to help you understand how to use the `fs` module effectively.

---

### **What is the `fs` Module?**
The `fs` module is a built-in Node.js module that allows you to perform operations like reading, writing, updating, and deleting files or directories. It supports both **synchronous** (blocking) and **asynchronous** (non-blocking, callback-based) methods.

To use the `fs` module, you need to import it:
```javascript
const fs = require('fs');
```

---

### **Key Concepts**
1. **Synchronous Methods**: These methods block the execution of the program until the operation is complete. They are suffixed with `Sync` (e.g., `fs.readFileSync`). Use these when you want simple, straightforward code but be cautious as they can slow down your application, especially with large files or heavy I/O operations.

2. **Asynchronous Methods (Callback-Based)**: These methods are non-blocking and take a callback function that is executed once the operation completes. They are preferred for performance in most applications, especially when handling multiple file operations.

3. **Error Handling**: Both synchronous and asynchronous methods require proper error handling to manage issues like missing files or permission errors.

---

### **Common `fs` Module Methods**
Below are some commonly used methods in the `fs` module, covering both synchronous and asynchronous (callback-based) approaches.

#### **1. Reading Files**
- **Asynchronous**: `fs.readFile(path, [options], callback)`
  - Reads the contents of a file asynchronously.
  - The callback function receives `(err, data)` as arguments.
  - `data` is a Buffer unless an encoding (e.g., `'utf8'`) is specified.
  - Example:
    ```javascript
    fs.readFile('example.txt', 'utf8', (err, data) => {
      if (err) {
        console.error('Error reading file:', err);
        return;
      }
      console.log('File contents:', data);
    });
    ```

- **Synchronous**: `fs.readFileSync(path, [options])`
  - Reads the file synchronously and returns the contents directly.
  - Throws an error if the operation fails, so use try-catch.
  - Example:
    ```javascript
    try {
      const data = fs.readFileSync('example.txt', 'utf8');
      console.log('File contents:', data);
    } catch (err) {
      console.error('Error reading file:', err);
    }
    ```

#### **2. Writing Files**
- **Asynchronous**: `fs.writeFile(path, data, [options], callback)`
  - Writes data to a file, overwriting it if it exists.
  - The callback receives an `err` argument.
  - Example:
    ```javascript
    fs.writeFile('output.txt', 'Hello, World!', (err) => {
      if (err) {
        console.error('Error writing file:', err);
        return;
      }
      console.log('File written successfully');
    });
    ```

- **Synchronous**: `fs.writeFileSync(path, data, [options])`
  - Writes data to a file synchronously.
  - Throws an error if the operation fails.
  - Example:
    ```javascript
    try {
      fs.writeFileSync('output.txt', 'Hello, World!');
      console.log('File written successfully');
    } catch (err) {
      console.error('Error writing file:', err);
    }
    ```

#### **3. Appending to Files**
- **Asynchronous**: `fs.appendFile(path, data, [options], callback)`
  - Appends data to a file. If the file doesn’t exist, it creates one.
  - Example:
    ```javascript
    fs.appendFile('log.txt', 'New log entry\n', (err) => {
      if (err) {
        console.error('Error appending to file:', err);
        return;
      }
      console.log('Data appended successfully');
    });
    ```

- **Synchronous**: `fs.appendFileSync(path, data, [options])`
  - Appends data synchronously.
  - Example:
    ```javascript
    try {
      fs.appendFileSync('log.txt', 'New log entry\n');
      console.log('Data appended successfully');
    } catch (err) {
      console.error('Error appending to file:', err);
    }
    ```

#### **4. Checking if a File Exists**
- **Asynchronous**: `fs.access(path, [mode], callback)`
  - Checks if a file exists or is accessible with the specified mode (e.g., `fs.constants.F_OK` for existence).
  - Example:
    ```javascript
    fs.access('example.txt', fs.constants.F_OK, (err) => {
      if (err) {
        console.error('File does not exist or is inaccessible:', err);
        return;
      }
      console.log('File exists');
    });
    ```

- **Synchronous**: `fs.existsSync(path)`
  - Returns `true` if the file exists, `false` otherwise.
  - Example:
    ```javascript
    if (fs.existsSync('example.txt')) {
      console.log('File exists');
    } else {
      console.error('File does not exist');
    }
    ```

#### **5. Deleting Files**
- **Asynchronous**: `fs.unlink(path, callback)`
  - Deletes a file.
  - Example:
    ```javascript
    fs.unlink('output.txt', (err) => {
      if (err) {
        console.error('Error deleting file:', err);
        return;
      }
      console.log('File deleted successfully');
    });
    ```

- **Synchronous**: `fs.unlinkSync(path)`
  - Deletes a file synchronously.
  - Example:
    ```javascript
    try {
      fs.unlinkSync('output.txt');
      console.log('File deleted successfully');
    } catch (err) {
      console.error('Error deleting file:', err);
    }
    ```

#### **6. Working with Directories**
- **Creating a Directory**:
  - Asynchronous: `fs.mkdir(path, [options], callback)`
    ```javascript
    fs.mkdir('new_folder', (err) => {
      if (err) {
        console.error('Error creating directory:', err);
        return;
      }
      console.log('Directory created successfully');
    });
    ```
  - Synchronous: `fs.mkdirSync(path, [options])`
    ```javascript
    try {
      fs.mkdirSync('new_folder');
      console.log('Directory created successfully');
    } catch (err) {
      console.error('Error creating directory:', err);
    }
    ```

- **Reading a Directory**:
  - Asynchronous: `fs.readdir(path, [options], callback)`
    ```javascript
    fs.readdir('.', (err, files) => {
      if (err) {
        console.error('Error reading directory:', err);
        return;
      }
      console.log('Directory contents:', files);
    });
    ```
  - Synchronous: `fs.readdirSync(path, [options])`
    ```javascript
    try {
      const files = fs.readdirSync('.');
      console.log('Directory contents:', files);
    } catch (err) {
      console.error('Error reading directory:', err);
    }
    ```

---

### **Key Differences: Synchronous vs. Asynchronous**
- **Synchronous**:
  - Blocking: The program waits for the operation to complete.
  - Easier to write and read, especially for small scripts.
  - Not suitable for high-performance applications or handling large files, as it can freeze the event loop.
  - Use for one-off scripts or initialization tasks.

- **Asynchronous (Callback-Based)**:
  - Non-blocking: Other code can run while the operation is in progress.
  - Better for performance in server applications or when handling multiple operations.
  - Requires callback functions, which can lead to "callback hell" if not managed properly.

---

### **Error Handling**
- **Asynchronous**: Always check the `err` parameter in the callback.
  ```javascript
  fs.readFile('nonexistent.txt', 'utf8', (err, data) => {
    if (err) {
      console.error('Error:', err.code, err.message);
      return;
    }
    console.log(data);
  });
  ```

- **Synchronous**: Use try-catch to handle errors.
  ```javascript
  try {
    const data = fs.readFileSync('nonexistent.txt', 'utf8');
    console.log(data);
  } catch (err) {
    console.error('Error:', err.code, err.message);
  }
  ```

Common error codes:
- `ENOENT`: File or directory does not exist.
- `EACCES`: Permission denied.
- `EISDIR`: Path is a directory, not a file.

---

### **Practical Example: Combining Methods**
Here’s an example that demonstrates reading, writing, and appending to a file using both synchronous and asynchronous methods.

```javascript
const fs = require('fs');

// Asynchronous: Read, append, and write
fs.readFile('input.txt', 'utf8', (err, data) => {
  if (err) {
    console.error('Error reading file:', err);
    return;
  }
  console.log('Original content:', data);

  // Append asynchronously
  fs.appendFile('input.txt', '\nAppended text', (err) => {
    if (err) {
      console.error('Error appending to file:', err);
      return;
    }
    console.log('Text appended successfully');

    // Write new file asynchronously
    fs.writeFile('output.txt', data + '\nCopied with append', (err) => {
      if (err) {
        console.error('Error writing file:', err);
        return;
      }
      console.log('New file written successfully');
    });
  });
});

// Synchronous: Same operations
try {
  const data = fs.readFileSync('input.txt', 'utf8');
  console.log('Original content (sync):', data);

  fs.appendFileSync('input.txt', '\nAppended text (sync)');
  console.log('Text appended successfully (sync)');

  fs.writeFileSync('output.txt', data + '\nCopied with append (sync)');
  console.log('New file written successfully (sync)');
} catch (err) {
  console.error('Error (sync):', err);
}
```

---

### **Best Practices**
1. **Use Asynchronous Methods for Performance**: Prefer callback-based methods in production applications to avoid blocking the event loop.
2. **Handle Errors Properly**: Always include error handling to prevent crashes.
3. **Use Synchronous Methods Sparingly**: Reserve synchronous methods for scripts or initialization tasks where simplicity is more important than performance.
4. **Specify Encoding for Text Files**: Use `'utf8'` when reading or writing text files to get strings instead of Buffers.
5. **Avoid Callback Hell**: For complex asynchronous operations, consider structuring your code with named functions or using other patterns (though you requested avoiding promises).

---

### **Additional Notes**
- **File Paths**: Use `path.join` from the `path` module for cross-platform compatibility when constructing file paths.
  ```javascript
  const path = require('path');
  const filePath = path.join(__dirname, 'example.txt');
  fs.readFile(filePath, 'utf8', (err, data) => { /* ... */ });
  ```

- **File Permissions**: Be aware of file permissions and user access when performing operations.
- **Large Files**: For large files, consider using streams (`fs.createReadStream`, `fs.createWriteStream`) to avoid loading the entire file into memory.

---

If you have a specific use case or need more examples (e.g., working with directories, streams, or specific file types), let me know, and I can provide tailored guidance!